/*
 * generated by Xtext 2.34.0
 */
package dk.sdu.mmmi.mdsd.ui23.serializer;

import com.google.inject.Inject;
import dk.sdu.mmmi.mdsd.ui23.services.Ui23GrammarAccess;
import dk.sdu.mmmi.mdsd.ui23.ui23.And;
import dk.sdu.mmmi.mdsd.ui23.ui23.BoolType;
import dk.sdu.mmmi.mdsd.ui23.ui23.Button;
import dk.sdu.mmmi.mdsd.ui23.ui23.Conc;
import dk.sdu.mmmi.mdsd.ui23.ui23.Div;
import dk.sdu.mmmi.mdsd.ui23.ui23.EQ;
import dk.sdu.mmmi.mdsd.ui23.ui23.Form;
import dk.sdu.mmmi.mdsd.ui23.ui23.FormUse;
import dk.sdu.mmmi.mdsd.ui23.ui23.Function;
import dk.sdu.mmmi.mdsd.ui23.ui23.GT;
import dk.sdu.mmmi.mdsd.ui23.ui23.GTE;
import dk.sdu.mmmi.mdsd.ui23.ui23.InputText;
import dk.sdu.mmmi.mdsd.ui23.ui23.LT;
import dk.sdu.mmmi.mdsd.ui23.ui23.LTE;
import dk.sdu.mmmi.mdsd.ui23.ui23.Label;
import dk.sdu.mmmi.mdsd.ui23.ui23.Layout;
import dk.sdu.mmmi.mdsd.ui23.ui23.Minus;
import dk.sdu.mmmi.mdsd.ui23.ui23.Mult;
import dk.sdu.mmmi.mdsd.ui23.ui23.NEQ;
import dk.sdu.mmmi.mdsd.ui23.ui23.NumberType;
import dk.sdu.mmmi.mdsd.ui23.ui23.Or;
import dk.sdu.mmmi.mdsd.ui23.ui23.Plus;
import dk.sdu.mmmi.mdsd.ui23.ui23.StringType;
import dk.sdu.mmmi.mdsd.ui23.ui23.UI;
import dk.sdu.mmmi.mdsd.ui23.ui23.Ui23Package;
import dk.sdu.mmmi.mdsd.ui23.ui23.ValueInt;
import dk.sdu.mmmi.mdsd.ui23.ui23.ValueString;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class Ui23SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Ui23GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Ui23Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Ui23Package.AND:
				sequence_Exp(context, (And) semanticObject); 
				return; 
			case Ui23Package.BOOL_TYPE:
				sequence_Type(context, (BoolType) semanticObject); 
				return; 
			case Ui23Package.BUTTON:
				sequence_Button(context, (Button) semanticObject); 
				return; 
			case Ui23Package.CONC:
				sequence_Concat(context, (Conc) semanticObject); 
				return; 
			case Ui23Package.DIV:
				sequence_Factor(context, (Div) semanticObject); 
				return; 
			case Ui23Package.EQ:
				sequence_Equality(context, (EQ) semanticObject); 
				return; 
			case Ui23Package.FORM:
				sequence_Form(context, (Form) semanticObject); 
				return; 
			case Ui23Package.FORM_USE:
				sequence_FormUse(context, (FormUse) semanticObject); 
				return; 
			case Ui23Package.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case Ui23Package.GT:
				sequence_Compare(context, (GT) semanticObject); 
				return; 
			case Ui23Package.GTE:
				sequence_Compare(context, (GTE) semanticObject); 
				return; 
			case Ui23Package.INPUT_TEXT:
				sequence_InputText(context, (InputText) semanticObject); 
				return; 
			case Ui23Package.LT:
				sequence_Compare(context, (LT) semanticObject); 
				return; 
			case Ui23Package.LTE:
				sequence_Compare(context, (LTE) semanticObject); 
				return; 
			case Ui23Package.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case Ui23Package.LAYOUT:
				sequence_Layout(context, (Layout) semanticObject); 
				return; 
			case Ui23Package.MINUS:
				sequence_AddMinus(context, (Minus) semanticObject); 
				return; 
			case Ui23Package.MULT:
				sequence_Factor(context, (Mult) semanticObject); 
				return; 
			case Ui23Package.NEQ:
				sequence_Equality(context, (NEQ) semanticObject); 
				return; 
			case Ui23Package.NUMBER_TYPE:
				sequence_Type(context, (NumberType) semanticObject); 
				return; 
			case Ui23Package.OR:
				sequence_Exp(context, (Or) semanticObject); 
				return; 
			case Ui23Package.PARAMETER:
				sequence_Parameter(context, (dk.sdu.mmmi.mdsd.ui23.ui23.Parameter) semanticObject); 
				return; 
			case Ui23Package.PLUS:
				sequence_AddMinus(context, (Plus) semanticObject); 
				return; 
			case Ui23Package.STRING_TYPE:
				sequence_Type(context, (StringType) semanticObject); 
				return; 
			case Ui23Package.UI:
				sequence_UI(context, (UI) semanticObject); 
				return; 
			case Ui23Package.VALUE_INT:
				sequence_Primary(context, (ValueInt) semanticObject); 
				return; 
			case Ui23Package.VALUE_STRING:
				sequence_Primary(context, (ValueString) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Minus
	 *     Exp.And_1_0_0_0 returns Minus
	 *     Exp.Or_1_0_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.EQ_1_0_0_0 returns Minus
	 *     Equality.NEQ_1_0_1_0 returns Minus
	 *     Compare returns Minus
	 *     Compare.LT_1_0_0_0 returns Minus
	 *     Compare.LTE_1_0_1_0 returns Minus
	 *     Compare.GT_1_0_2_0 returns Minus
	 *     Compare.GTE_1_0_3_0 returns Minus
	 *     Concat returns Minus
	 *     Concat.Conc_1_0_0 returns Minus
	 *     AddMinus returns Minus
	 *     AddMinus.Plus_1_0_0_0 returns Minus
	 *     AddMinus.Minus_1_0_1_0 returns Minus
	 *     Factor returns Minus
	 *     Factor.Mult_1_0_0_0 returns Minus
	 *     Factor.Div_1_0_1_0 returns Minus
	 *     Primary returns Minus
	 *
	 * Constraint:
	 *     (left=AddMinus_Minus_1_0_1_0 right=Factor)
	 * </pre>
	 */
	protected void sequence_AddMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddMinusAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Plus
	 *     Exp.And_1_0_0_0 returns Plus
	 *     Exp.Or_1_0_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.EQ_1_0_0_0 returns Plus
	 *     Equality.NEQ_1_0_1_0 returns Plus
	 *     Compare returns Plus
	 *     Compare.LT_1_0_0_0 returns Plus
	 *     Compare.LTE_1_0_1_0 returns Plus
	 *     Compare.GT_1_0_2_0 returns Plus
	 *     Compare.GTE_1_0_3_0 returns Plus
	 *     Concat returns Plus
	 *     Concat.Conc_1_0_0 returns Plus
	 *     AddMinus returns Plus
	 *     AddMinus.Plus_1_0_0_0 returns Plus
	 *     AddMinus.Minus_1_0_1_0 returns Plus
	 *     Factor returns Plus
	 *     Factor.Mult_1_0_0_0 returns Plus
	 *     Factor.Div_1_0_1_0 returns Plus
	 *     Primary returns Plus
	 *
	 * Constraint:
	 *     (left=AddMinus_Plus_1_0_0_0 right=Factor)
	 * </pre>
	 */
	protected void sequence_AddMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddMinusAccess().getRightFactorParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Button
	 *     Element returns Button
	 *     Button returns Button
	 *
	 * Constraint:
	 *     (name=ID exp=Exp)
	 * </pre>
	 */
	protected void sequence_Button(ISerializationContext context, Button semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.BUTTON__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.BUTTON__NAME));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.ELEMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.ELEMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getButtonAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getButtonAccess().getExpExpParserRuleCall_4_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns GT
	 *     Exp.And_1_0_0_0 returns GT
	 *     Exp.Or_1_0_1_0 returns GT
	 *     Equality returns GT
	 *     Equality.EQ_1_0_0_0 returns GT
	 *     Equality.NEQ_1_0_1_0 returns GT
	 *     Compare returns GT
	 *     Compare.LT_1_0_0_0 returns GT
	 *     Compare.LTE_1_0_1_0 returns GT
	 *     Compare.GT_1_0_2_0 returns GT
	 *     Compare.GTE_1_0_3_0 returns GT
	 *     Concat returns GT
	 *     Concat.Conc_1_0_0 returns GT
	 *     AddMinus returns GT
	 *     AddMinus.Plus_1_0_0_0 returns GT
	 *     AddMinus.Minus_1_0_1_0 returns GT
	 *     Factor returns GT
	 *     Factor.Mult_1_0_0_0 returns GT
	 *     Factor.Div_1_0_1_0 returns GT
	 *     Primary returns GT
	 *
	 * Constraint:
	 *     (left=Compare_GT_1_0_2_0 right=Concat)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, GT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.GT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.GT__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.GT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.GT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getGTLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightConcatParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns GTE
	 *     Exp.And_1_0_0_0 returns GTE
	 *     Exp.Or_1_0_1_0 returns GTE
	 *     Equality returns GTE
	 *     Equality.EQ_1_0_0_0 returns GTE
	 *     Equality.NEQ_1_0_1_0 returns GTE
	 *     Compare returns GTE
	 *     Compare.LT_1_0_0_0 returns GTE
	 *     Compare.LTE_1_0_1_0 returns GTE
	 *     Compare.GT_1_0_2_0 returns GTE
	 *     Compare.GTE_1_0_3_0 returns GTE
	 *     Concat returns GTE
	 *     Concat.Conc_1_0_0 returns GTE
	 *     AddMinus returns GTE
	 *     AddMinus.Plus_1_0_0_0 returns GTE
	 *     AddMinus.Minus_1_0_1_0 returns GTE
	 *     Factor returns GTE
	 *     Factor.Mult_1_0_0_0 returns GTE
	 *     Factor.Div_1_0_1_0 returns GTE
	 *     Primary returns GTE
	 *
	 * Constraint:
	 *     (left=Compare_GTE_1_0_3_0 right=Concat)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, GTE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.GTE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.GTE__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.GTE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.GTE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getGTELeftAction_1_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightConcatParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns LT
	 *     Exp.And_1_0_0_0 returns LT
	 *     Exp.Or_1_0_1_0 returns LT
	 *     Equality returns LT
	 *     Equality.EQ_1_0_0_0 returns LT
	 *     Equality.NEQ_1_0_1_0 returns LT
	 *     Compare returns LT
	 *     Compare.LT_1_0_0_0 returns LT
	 *     Compare.LTE_1_0_1_0 returns LT
	 *     Compare.GT_1_0_2_0 returns LT
	 *     Compare.GTE_1_0_3_0 returns LT
	 *     Concat returns LT
	 *     Concat.Conc_1_0_0 returns LT
	 *     AddMinus returns LT
	 *     AddMinus.Plus_1_0_0_0 returns LT
	 *     AddMinus.Minus_1_0_1_0 returns LT
	 *     Factor returns LT
	 *     Factor.Mult_1_0_0_0 returns LT
	 *     Factor.Div_1_0_1_0 returns LT
	 *     Primary returns LT
	 *
	 * Constraint:
	 *     (left=Compare_LT_1_0_0_0 right=Concat)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, LT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.LT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.LT__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.LT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.LT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getLTLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightConcatParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns LTE
	 *     Exp.And_1_0_0_0 returns LTE
	 *     Exp.Or_1_0_1_0 returns LTE
	 *     Equality returns LTE
	 *     Equality.EQ_1_0_0_0 returns LTE
	 *     Equality.NEQ_1_0_1_0 returns LTE
	 *     Compare returns LTE
	 *     Compare.LT_1_0_0_0 returns LTE
	 *     Compare.LTE_1_0_1_0 returns LTE
	 *     Compare.GT_1_0_2_0 returns LTE
	 *     Compare.GTE_1_0_3_0 returns LTE
	 *     Concat returns LTE
	 *     Concat.Conc_1_0_0 returns LTE
	 *     AddMinus returns LTE
	 *     AddMinus.Plus_1_0_0_0 returns LTE
	 *     AddMinus.Minus_1_0_1_0 returns LTE
	 *     Factor returns LTE
	 *     Factor.Mult_1_0_0_0 returns LTE
	 *     Factor.Div_1_0_1_0 returns LTE
	 *     Primary returns LTE
	 *
	 * Constraint:
	 *     (left=Compare_LTE_1_0_1_0 right=Concat)
	 * </pre>
	 */
	protected void sequence_Compare(ISerializationContext context, LTE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.LTE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.LTE__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.LTE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.LTE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareAccess().getLTELeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareAccess().getRightConcatParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Conc
	 *     Exp.And_1_0_0_0 returns Conc
	 *     Exp.Or_1_0_1_0 returns Conc
	 *     Equality returns Conc
	 *     Equality.EQ_1_0_0_0 returns Conc
	 *     Equality.NEQ_1_0_1_0 returns Conc
	 *     Compare returns Conc
	 *     Compare.LT_1_0_0_0 returns Conc
	 *     Compare.LTE_1_0_1_0 returns Conc
	 *     Compare.GT_1_0_2_0 returns Conc
	 *     Compare.GTE_1_0_3_0 returns Conc
	 *     Concat returns Conc
	 *     Concat.Conc_1_0_0 returns Conc
	 *     AddMinus returns Conc
	 *     AddMinus.Plus_1_0_0_0 returns Conc
	 *     AddMinus.Minus_1_0_1_0 returns Conc
	 *     Factor returns Conc
	 *     Factor.Mult_1_0_0_0 returns Conc
	 *     Factor.Div_1_0_1_0 returns Conc
	 *     Primary returns Conc
	 *
	 * Constraint:
	 *     (left=Concat_Conc_1_0_0 right=AddMinus)
	 * </pre>
	 */
	protected void sequence_Concat(ISerializationContext context, Conc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.CONC__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.CONC__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.CONC__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.CONC__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcatAccess().getConcLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConcatAccess().getRightAddMinusParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns EQ
	 *     Exp.And_1_0_0_0 returns EQ
	 *     Exp.Or_1_0_1_0 returns EQ
	 *     Equality returns EQ
	 *     Equality.EQ_1_0_0_0 returns EQ
	 *     Equality.NEQ_1_0_1_0 returns EQ
	 *     Compare returns EQ
	 *     Compare.LT_1_0_0_0 returns EQ
	 *     Compare.LTE_1_0_1_0 returns EQ
	 *     Compare.GT_1_0_2_0 returns EQ
	 *     Compare.GTE_1_0_3_0 returns EQ
	 *     Concat returns EQ
	 *     Concat.Conc_1_0_0 returns EQ
	 *     AddMinus returns EQ
	 *     AddMinus.Plus_1_0_0_0 returns EQ
	 *     AddMinus.Minus_1_0_1_0 returns EQ
	 *     Factor returns EQ
	 *     Factor.Mult_1_0_0_0 returns EQ
	 *     Factor.Div_1_0_1_0 returns EQ
	 *     Primary returns EQ
	 *
	 * Constraint:
	 *     (left=Equality_EQ_1_0_0_0 right=Compare)
	 * </pre>
	 */
	protected void sequence_Equality(ISerializationContext context, EQ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.EQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.EQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.EQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.EQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEQLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getRightCompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns NEQ
	 *     Exp.And_1_0_0_0 returns NEQ
	 *     Exp.Or_1_0_1_0 returns NEQ
	 *     Equality returns NEQ
	 *     Equality.EQ_1_0_0_0 returns NEQ
	 *     Equality.NEQ_1_0_1_0 returns NEQ
	 *     Compare returns NEQ
	 *     Compare.LT_1_0_0_0 returns NEQ
	 *     Compare.LTE_1_0_1_0 returns NEQ
	 *     Compare.GT_1_0_2_0 returns NEQ
	 *     Compare.GTE_1_0_3_0 returns NEQ
	 *     Concat returns NEQ
	 *     Concat.Conc_1_0_0 returns NEQ
	 *     AddMinus returns NEQ
	 *     AddMinus.Plus_1_0_0_0 returns NEQ
	 *     AddMinus.Minus_1_0_1_0 returns NEQ
	 *     Factor returns NEQ
	 *     Factor.Mult_1_0_0_0 returns NEQ
	 *     Factor.Div_1_0_1_0 returns NEQ
	 *     Primary returns NEQ
	 *
	 * Constraint:
	 *     (left=Equality_NEQ_1_0_1_0 right=Compare)
	 * </pre>
	 */
	protected void sequence_Equality(ISerializationContext context, NEQ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.NEQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.NEQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.NEQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.NEQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getNEQLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getRightCompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns And
	 *     Exp.And_1_0_0_0 returns And
	 *     Exp.Or_1_0_1_0 returns And
	 *     Equality returns And
	 *     Equality.EQ_1_0_0_0 returns And
	 *     Equality.NEQ_1_0_1_0 returns And
	 *     Compare returns And
	 *     Compare.LT_1_0_0_0 returns And
	 *     Compare.LTE_1_0_1_0 returns And
	 *     Compare.GT_1_0_2_0 returns And
	 *     Compare.GTE_1_0_3_0 returns And
	 *     Concat returns And
	 *     Concat.Conc_1_0_0 returns And
	 *     AddMinus returns And
	 *     AddMinus.Plus_1_0_0_0 returns And
	 *     AddMinus.Minus_1_0_1_0 returns And
	 *     Factor returns And
	 *     Factor.Mult_1_0_0_0 returns And
	 *     Factor.Div_1_0_1_0 returns And
	 *     Primary returns And
	 *
	 * Constraint:
	 *     (left=Exp_And_1_0_0_0 right=Equality)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getAndLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightEqualityParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Or
	 *     Exp.And_1_0_0_0 returns Or
	 *     Exp.Or_1_0_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.EQ_1_0_0_0 returns Or
	 *     Equality.NEQ_1_0_1_0 returns Or
	 *     Compare returns Or
	 *     Compare.LT_1_0_0_0 returns Or
	 *     Compare.LTE_1_0_1_0 returns Or
	 *     Compare.GT_1_0_2_0 returns Or
	 *     Compare.GTE_1_0_3_0 returns Or
	 *     Concat returns Or
	 *     Concat.Conc_1_0_0 returns Or
	 *     AddMinus returns Or
	 *     AddMinus.Plus_1_0_0_0 returns Or
	 *     AddMinus.Minus_1_0_1_0 returns Or
	 *     Factor returns Or
	 *     Factor.Mult_1_0_0_0 returns Or
	 *     Factor.Div_1_0_1_0 returns Or
	 *     Primary returns Or
	 *
	 * Constraint:
	 *     (left=Exp_Or_1_0_1_0 right=Equality)
	 * </pre>
	 */
	protected void sequence_Exp(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpAccess().getOrLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpAccess().getRightEqualityParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Div
	 *     Exp.And_1_0_0_0 returns Div
	 *     Exp.Or_1_0_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.EQ_1_0_0_0 returns Div
	 *     Equality.NEQ_1_0_1_0 returns Div
	 *     Compare returns Div
	 *     Compare.LT_1_0_0_0 returns Div
	 *     Compare.LTE_1_0_1_0 returns Div
	 *     Compare.GT_1_0_2_0 returns Div
	 *     Compare.GTE_1_0_3_0 returns Div
	 *     Concat returns Div
	 *     Concat.Conc_1_0_0 returns Div
	 *     AddMinus returns Div
	 *     AddMinus.Plus_1_0_0_0 returns Div
	 *     AddMinus.Minus_1_0_1_0 returns Div
	 *     Factor returns Div
	 *     Factor.Mult_1_0_0_0 returns Div
	 *     Factor.Div_1_0_1_0 returns Div
	 *     Primary returns Div
	 *
	 * Constraint:
	 *     (left=Factor_Div_1_0_1_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_Factor(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns Mult
	 *     Exp.And_1_0_0_0 returns Mult
	 *     Exp.Or_1_0_1_0 returns Mult
	 *     Equality returns Mult
	 *     Equality.EQ_1_0_0_0 returns Mult
	 *     Equality.NEQ_1_0_1_0 returns Mult
	 *     Compare returns Mult
	 *     Compare.LT_1_0_0_0 returns Mult
	 *     Compare.LTE_1_0_1_0 returns Mult
	 *     Compare.GT_1_0_2_0 returns Mult
	 *     Compare.GTE_1_0_3_0 returns Mult
	 *     Concat returns Mult
	 *     Concat.Conc_1_0_0 returns Mult
	 *     AddMinus returns Mult
	 *     AddMinus.Plus_1_0_0_0 returns Mult
	 *     AddMinus.Minus_1_0_1_0 returns Mult
	 *     Factor returns Mult
	 *     Factor.Mult_1_0_0_0 returns Mult
	 *     Factor.Div_1_0_1_0 returns Mult
	 *     Primary returns Mult
	 *
	 * Constraint:
	 *     (left=Factor_Mult_1_0_0_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_Factor(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.MULT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.MULT__LEFT));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.MULT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.MULT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactorAccess().getMultLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getFactorAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns FormUse
	 *     FormUse returns FormUse
	 *
	 * Constraint:
	 *     (name=ID (exp=Exp exp=Exp*)?)
	 * </pre>
	 */
	protected void sequence_FormUse(ISerializationContext context, FormUse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Form returns Form
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Parameter parameters+=Parameter*)? layout=Layout)
	 * </pre>
	 */
	protected void sequence_Form(ISerializationContext context, Form semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID (types+=Type types+=Type*)? types+=Type)
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns InputText
	 *     Element returns InputText
	 *     InputText returns InputText
	 *
	 * Constraint:
	 *     (name=ID exp=Exp)
	 * </pre>
	 */
	protected void sequence_InputText(ISerializationContext context, InputText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.INPUT_TEXT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.INPUT_TEXT__NAME));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.ELEMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.ELEMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputTextAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInputTextAccess().getExpExpParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Label
	 *     Element returns Label
	 *     Label returns Label
	 *
	 * Constraint:
	 *     exp=Exp
	 * </pre>
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.ELEMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.ELEMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getExpExpParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Layout returns Layout
	 *     Component returns Layout
	 *
	 * Constraint:
	 *     components+=Component+
	 * </pre>
	 */
	protected void sequence_Layout(ISerializationContext context, Layout semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, dk.sdu.mmmi.mdsd.ui23.ui23.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.PARAMETER__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns ValueInt
	 *     Exp.And_1_0_0_0 returns ValueInt
	 *     Exp.Or_1_0_1_0 returns ValueInt
	 *     Equality returns ValueInt
	 *     Equality.EQ_1_0_0_0 returns ValueInt
	 *     Equality.NEQ_1_0_1_0 returns ValueInt
	 *     Compare returns ValueInt
	 *     Compare.LT_1_0_0_0 returns ValueInt
	 *     Compare.LTE_1_0_1_0 returns ValueInt
	 *     Compare.GT_1_0_2_0 returns ValueInt
	 *     Compare.GTE_1_0_3_0 returns ValueInt
	 *     Concat returns ValueInt
	 *     Concat.Conc_1_0_0 returns ValueInt
	 *     AddMinus returns ValueInt
	 *     AddMinus.Plus_1_0_0_0 returns ValueInt
	 *     AddMinus.Minus_1_0_1_0 returns ValueInt
	 *     Factor returns ValueInt
	 *     Factor.Mult_1_0_0_0 returns ValueInt
	 *     Factor.Div_1_0_1_0 returns ValueInt
	 *     Primary returns ValueInt
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, ValueInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.VALUE_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.VALUE_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Exp returns ValueString
	 *     Exp.And_1_0_0_0 returns ValueString
	 *     Exp.Or_1_0_1_0 returns ValueString
	 *     Equality returns ValueString
	 *     Equality.EQ_1_0_0_0 returns ValueString
	 *     Equality.NEQ_1_0_1_0 returns ValueString
	 *     Compare returns ValueString
	 *     Compare.LT_1_0_0_0 returns ValueString
	 *     Compare.LTE_1_0_1_0 returns ValueString
	 *     Compare.GT_1_0_2_0 returns ValueString
	 *     Compare.GTE_1_0_3_0 returns ValueString
	 *     Concat returns ValueString
	 *     Concat.Conc_1_0_0 returns ValueString
	 *     AddMinus returns ValueString
	 *     AddMinus.Plus_1_0_0_0 returns ValueString
	 *     AddMinus.Minus_1_0_1_0 returns ValueString
	 *     Factor returns ValueString
	 *     Factor.Mult_1_0_0_0 returns ValueString
	 *     Factor.Div_1_0_1_0 returns ValueString
	 *     Primary returns ValueString
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_Primary(ISerializationContext context, ValueString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Ui23Package.Literals.VALUE_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Ui23Package.Literals.VALUE_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns BoolType
	 *     Exp returns BoolType
	 *     Exp.And_1_0_0_0 returns BoolType
	 *     Exp.Or_1_0_1_0 returns BoolType
	 *     Equality returns BoolType
	 *     Equality.EQ_1_0_0_0 returns BoolType
	 *     Equality.NEQ_1_0_1_0 returns BoolType
	 *     Compare returns BoolType
	 *     Compare.LT_1_0_0_0 returns BoolType
	 *     Compare.LTE_1_0_1_0 returns BoolType
	 *     Compare.GT_1_0_2_0 returns BoolType
	 *     Compare.GTE_1_0_3_0 returns BoolType
	 *     Concat returns BoolType
	 *     Concat.Conc_1_0_0 returns BoolType
	 *     AddMinus returns BoolType
	 *     AddMinus.Plus_1_0_0_0 returns BoolType
	 *     AddMinus.Minus_1_0_1_0 returns BoolType
	 *     Factor returns BoolType
	 *     Factor.Mult_1_0_0_0 returns BoolType
	 *     Factor.Div_1_0_1_0 returns BoolType
	 *     Primary returns BoolType
	 *
	 * Constraint:
	 *     {BoolType}
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, BoolType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns NumberType
	 *     Exp returns NumberType
	 *     Exp.And_1_0_0_0 returns NumberType
	 *     Exp.Or_1_0_1_0 returns NumberType
	 *     Equality returns NumberType
	 *     Equality.EQ_1_0_0_0 returns NumberType
	 *     Equality.NEQ_1_0_1_0 returns NumberType
	 *     Compare returns NumberType
	 *     Compare.LT_1_0_0_0 returns NumberType
	 *     Compare.LTE_1_0_1_0 returns NumberType
	 *     Compare.GT_1_0_2_0 returns NumberType
	 *     Compare.GTE_1_0_3_0 returns NumberType
	 *     Concat returns NumberType
	 *     Concat.Conc_1_0_0 returns NumberType
	 *     AddMinus returns NumberType
	 *     AddMinus.Plus_1_0_0_0 returns NumberType
	 *     AddMinus.Minus_1_0_1_0 returns NumberType
	 *     Factor returns NumberType
	 *     Factor.Mult_1_0_0_0 returns NumberType
	 *     Factor.Div_1_0_1_0 returns NumberType
	 *     Primary returns NumberType
	 *
	 * Constraint:
	 *     {NumberType}
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, NumberType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns StringType
	 *     Exp returns StringType
	 *     Exp.And_1_0_0_0 returns StringType
	 *     Exp.Or_1_0_1_0 returns StringType
	 *     Equality returns StringType
	 *     Equality.EQ_1_0_0_0 returns StringType
	 *     Equality.NEQ_1_0_1_0 returns StringType
	 *     Compare returns StringType
	 *     Compare.LT_1_0_0_0 returns StringType
	 *     Compare.LTE_1_0_1_0 returns StringType
	 *     Compare.GT_1_0_2_0 returns StringType
	 *     Compare.GTE_1_0_3_0 returns StringType
	 *     Concat returns StringType
	 *     Concat.Conc_1_0_0 returns StringType
	 *     AddMinus returns StringType
	 *     AddMinus.Plus_1_0_0_0 returns StringType
	 *     AddMinus.Minus_1_0_1_0 returns StringType
	 *     Factor returns StringType
	 *     Factor.Mult_1_0_0_0 returns StringType
	 *     Factor.Div_1_0_1_0 returns StringType
	 *     Primary returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 * </pre>
	 */
	protected void sequence_Type(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UI returns UI
	 *
	 * Constraint:
	 *     (title=ID functions+=Function* forms+=Form*)
	 * </pre>
	 */
	protected void sequence_UI(ISerializationContext context, UI semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
